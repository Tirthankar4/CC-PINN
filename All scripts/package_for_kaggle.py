"""Bundle the modular codebase into a single Kaggle-friendly script.

Running this script produces ``kaggle_script.py`` which contains the
combined source code for all internal modules followed by ``train.py``.
The generated file can be uploaded to Kaggle (together with ``config.py``)
without needing the original folder structure.
"""
from __future__ import annotations

import ast
from pathlib import Path
from typing import List, Tuple


ROOT = Path(__file__).parent
OUTPUT_FILE = ROOT / "kaggle_script.py"

PACKAGE_NAMES = [
    "core",
    "methods",
    "numerical_solvers",
    "training",
    "utilities",
    "visualization",
]

# Order matters: parents before dependants so imports succeed in the packed file.
MODULE_SPECS: List[Tuple[str, str]] = [
    ("core/data_generator.py", "core.data_generator"),
    ("numerical_solvers/LAX.py", "numerical_solvers.LAX"),
    ("numerical_solvers/LAX_torch.py", "numerical_solvers.LAX_torch"),
    ("core/initial_conditions.py", "core.initial_conditions"),
    ("core/losses.py", "core.losses"),
    ("core/model_architecture.py", "core.model_architecture"),
    ("training/training_diagnostics.py", "training.training_diagnostics"),
    ("training/physics.py", "training.physics"),
    ("training/trainer.py", "training.trainer"),
    ("visualization/Plotting.py", "visualization.Plotting"),
    ("visualization/Interactive.py", "visualization.Interactive"),
    ("train.py", "train"),
]


def _collect_defined_names(path: Path) -> List[str]:
    """Return top-level symbol names defined in ``path`` for module registration."""
    source = path.read_text(encoding="utf-8")
    tree = ast.parse(source, filename=str(path))
    names = set()

    for node in tree.body:
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
            names.add(node.name)
        elif isinstance(node, ast.Assign):
            for target in node.targets:
                if isinstance(target, ast.Name):
                    names.add(target.id)
        elif isinstance(node, ast.AnnAssign) and isinstance(node.target, ast.Name):
            names.add(node.target.id)

    return sorted(names)


def build_kaggle_script() -> str:
    header_lines = [
        "# Auto-generated by package_for_kaggle.py",
        "# Do not edit manually; regenerate from the modular codebase instead.",
        "import sys",
        "import types",
        "",
        "def _register_module(module_name, attr_names):",
        "    module = types.ModuleType(module_name)",
        "    module.__package__ = module_name",
        "    for attr in attr_names:",
        "        if attr in globals():",
        "            module.__dict__[attr] = globals()[attr]",
        "    sys.modules[module_name] = module",
        "    parts = module_name.split('.')",
        "    for i in range(1, len(parts)):",
        "        parent_name = '.'.join(parts[:i])",
        "        if parent_name not in sys.modules:",
        "            parent_module = types.ModuleType(parent_name)",
        "            parent_module.__package__ = parent_name",
        "            parent_module.__path__ = []",
        "            sys.modules[parent_name] = parent_module",
        "            if i == 1:",
        "                globals()[parts[0]] = parent_module",
        "    if len(parts) > 1:",
        "        parent = sys.modules['.'.join(parts[:-1])]",
        "        setattr(parent, parts[-1], module)",
        "        module.__package__ = parent.__name__",
        "    else:",
        "        globals()[parts[0]] = module",
        "    if '__path__' not in module.__dict__:",
        "        module.__path__ = []",
        "    return module",
        "",
    ]

    for package_name in PACKAGE_NAMES:
        header_lines.extend([
            f"if '{package_name}' not in sys.modules:",
            f"    {package_name}_module = types.ModuleType('{package_name}')",
            f"    {package_name}_module.__package__ = '{package_name}'",
            f"    {package_name}_module.__path__ = []",
            f"    sys.modules['{package_name}'] = {package_name}_module",
            f"    globals()['{package_name}'] = {package_name}_module",
            "",
        ])

    body_lines: List[str] = header_lines.copy()

    for rel_path, module_name in MODULE_SPECS:
        path = ROOT / rel_path
        if not path.exists():
            raise FileNotFoundError(f"Required module not found: {rel_path}")

        module_source = path.read_text(encoding="utf-8").rstrip()
        defined_names = _collect_defined_names(path)

        body_lines.append(f"# ==== Module: {module_name} ({rel_path}) ====")
        body_lines.append(module_source)
        attr_list = ", ".join(repr(name) for name in defined_names)
        body_lines.append(
            f"_register_module({module_name!r}, [{attr_list}])"
        )
        body_lines.append("")

    return "\n".join(body_lines) + "\n"


def main() -> None:
    script_text = build_kaggle_script()
    OUTPUT_FILE.write_text(script_text, encoding="utf-8")
    print(f"Created {OUTPUT_FILE.name} ({len(script_text.splitlines())} lines)")


if __name__ == "__main__":
    main()

